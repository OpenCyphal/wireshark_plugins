-- AUTOGENERATED, DO NOT EDIT.
--
-- Source file:
-- /Users/erikrain/Source/external/nunavut/submodules/public_regulated_data_types/uavcan/node/Mode.1.0.dsdl
--
-- Generated at:  2024-07-19 22:00:20.129464 UTC
-- Is deprecated: no
-- Fixed port ID: None
-- Full name:     uavcan.node.Mode
-- Version:       1.0
--
-- Type Information: Is uavcan.node.Mode a ?
-- Void:          no
-- Boolean:       no
-- Primitive:     no
-- Integer:       no
-- Float:         no
-- ArrayType:     no
-- FixedLengthArray: no
-- VariableLengthArray: no
-- Composite:     yes
-- Delimited:     no
-- Union:         no
-- Service:       no

-- We always use the generated nunavut support
local nunavut_support = require('nunavut_support')


-- constants
local OPERATIONAL = 0
local INITIALIZATION = 1
local MAINTENANCE = 2
local SOFTWARE_UPDATE = 3
local BIT_EXTENT = 8
local EXTENT = BIT_EXTENT / 8

-- constituent fields
local uavcan_node_Mode_1_0_value = ProtoField.new(
    'value', -- name in the shown fields
    'uavcan.node.Mode_1_0.value', -- abbr named used by filters
     ftypes.UINT8) -- field type


-- local flag to prevent multiple inclusion
local uavcan_node_Mode_1_0_registered = false

-- Registers the fields of the message to the Proto
-- @param cyphal_proto The Proto to add the fields to
local function register_uavcan_node_Mode_1_0(cyphal_proto)
    if not uavcan_node_Mode_1_0_registered then
        table.insert(cyphal_proto.fields, uavcan_node_Mode_1_0_value)
        uavcan_node_Mode_1_0_registered = true
        print("Registerd uavcan.node.Mode_1_0")
    end
end

-- Decodes a uavcan_node_Mode_1_0
-- Returns the number of bytes decoded
local function decode_uavcan_node_Mode_1_0(proto, payload, pinfo, payload_tree, label)
    local offset = 0 -- used to track the current byte offset through the decoded packet
    local _delimiter_ = 0 -- this may not be used in all circumstances, check for zero!
    local _length_ = 0 -- used for the length of variable length array
    local field_size = 0 -- used to track the extent of a field or it's _delimiter_ size.
    local extent = 0 -- used to track the current of this type
    if payload:len() == 0 then
        return 0
    end
    if payload:len() <= EXTENT then
        extent = payload:len()
    else
        error("Payload is too large for uavcan.node.Mode_1_0")
        extent = EXTENT
    end
    local subtree = payload_tree:add(proto, payload(0, extent), "uavcan.node.Mode_1_0")
    subtree:prepend_text(string.format("%s of type ", label))


    -- primitive type
    offset = offset + nunavut_support.as_uint8(
            uavcan_node_Mode_1_0_value,
            payload(offset, 1),
            pinfo, subtree, "value")


    return offset
end

-- Return the decode, register and the option port id
return {
    register = register_uavcan_node_Mode_1_0
    , decode = decode_uavcan_node_Mode_1_0
    , extent = EXTENT
}


